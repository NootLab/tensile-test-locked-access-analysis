import customtkinter as ctk
from tkinter import filedialog, messagebox
import matplotlib.pyplot as plt
import csv
import nbformat
from nbformat.v4 import new_notebook, new_code_cell, new_markdown_cell

# Set appearance mode and default color theme
ctk.set_appearance_mode("dark")
ctk.set_default_color_theme("blue")

class DataCollector:
    def __init__(self):
        self.columns = ["TestNo", "PlayTime", "LoadValue", "PositionValue"]
        self.data = {col: [] for col in self.columns}
        self.areas = {}  # TestNo -> area

    def add_chunk(self, col, chunk):
        lines = [line.strip() for line in chunk.splitlines() if line.strip()]
        self.data[col].extend(lines)
        return len(lines)

    def ready(self):
        lengths = [len(self.data[col]) for col in self.columns]
        return all(length == lengths[0] and length > 0 for length in lengths)

    def get_unique_testnos(self):
        return sorted(set(self.data["TestNo"]))

class AreaPrompt(ctk.CTkToplevel):
    def __init__(self, parent, testnos, callback):
        super().__init__(parent)
        self.title("Enter Cross-Sectional Area for Each TestNo")
        self.geometry("500x400")
        self.callback = callback
        self.entries = {}
        
        # Make window modal
        self.grab_set()
        
        # Title label
        title_label = ctk.CTkLabel(
            self, 
            text="Please enter cross-sectional area (mmÂ²) for each TestNo:",
            font=ctk.CTkFont(size=14, weight="bold")
        )
        title_label.pack(pady=(20, 10))
        
        # Scrollable frame for entries
        scroll_frame = ctk.CTkScrollableFrame(self, width=450, height=250)
        scroll_frame.pack(pady=10, padx=20, fill="both", expand=True)
        
        for testno in testnos:
            row = ctk.CTkFrame(scroll_frame, fg_color="transparent")
            row.pack(fill='x', pady=5)
            
            label = ctk.CTkLabel(row, text=f"TestNo {testno}:", width=150, anchor='w')
            label.pack(side='left', padx=5)
            
            entry = ctk.CTkEntry(row, width=200, placeholder_text="Enter area...")
            entry.pack(side='left', padx=5)
            self.entries[testno] = entry
        
        # Submit button
        btn = ctk.CTkButton(
            self, 
            text="Submit", 
            command=self.submit,
            width=200,
            height=40,
            font=ctk.CTkFont(size=14, weight="bold")
        )
        btn.pack(pady=20)

    def submit(self):
        areas = {}
        try:
            for testno, entry in self.entries.items():
                val = float(entry.get())
                areas[testno] = val
            self.callback(areas)
            self.destroy()
        except ValueError:
            messagebox.showerror("Input Error", "Please enter valid numeric values for all areas.")

class TensileStrengthGUI:
    def __init__(self, root):
        self.root = root
        root.title("Tensile Strength Data Collector")
        root.geometry("1200x900")
        
        self.collector = DataCollector()
        self.processed_rows = []  # Save processed rows for exporting

        # Configure grid
        root.grid_columnconfigure(0, weight=1)
        root.grid_rowconfigure(5, weight=1)

        # Header
        header = ctk.CTkLabel(
            root, 
            text="Tensile Strength Data Collector",
            font=ctk.CTkFont(size=24, weight="bold")
        )
        header.grid(row=0, column=0, pady=(20, 10), padx=20, sticky="ew")

        # Data Input Section
        input_frame = ctk.CTkFrame(root)
        input_frame.grid(row=1, column=0, pady=10, padx=20, sticky="ew")
        
        ctk.CTkLabel(
            input_frame, 
            text="Select Column and Paste Data:",
            font=ctk.CTkFont(size=16, weight="bold")
        ).pack(pady=(10, 5))

        # Column selector
        self.col_var = ctk.StringVar(value="TestNo")
        self.col_selector = ctk.CTkComboBox(
            input_frame,
            values=self.collector.columns,
            variable=self.col_var,
            command=self.update_chunk_count,
            width=300,
            height=35
        )
        self.col_selector.pack(pady=5)

        # Textbox for pasting data
        self.textbox = ctk.CTkTextbox(input_frame, width=1100, height=150)
        self.textbox.pack(pady=10, padx=10)

        # Add chunk button
        self.btn_add = ctk.CTkButton(
            input_frame,
            text="Add Chunk to Selected Column",
            command=self.add_chunk,
            width=300,
            height=40,
            font=ctk.CTkFont(size=14, weight="bold")
        )
        self.btn_add.pack(pady=10)

        # Chunk count label
        self.chunk_count_label = ctk.CTkLabel(
            input_frame,
            text=self.get_column_count_text(),
            font=ctk.CTkFont(size=12)
        )
        self.chunk_count_label.pack(pady=5)

        # Finish button
        self.btn_finish = ctk.CTkButton(
            root,
            text="Finish & Calculate",
            command=self.finish,
            width=300,
            height=45,
            font=ctk.CTkFont(size=16, weight="bold"),
            fg_color="#2B7A0B",
            hover_color="#1F5A08"
        )
        self.btn_finish.grid(row=2, column=0, pady=10)

        # Results Section
        results_frame = ctk.CTkFrame(root)
        results_frame.grid(row=3, column=0, pady=10, padx=20, sticky="ew")
        
        ctk.CTkLabel(
            results_frame,
            text="Results:",
            font=ctk.CTkFont(size=16, weight="bold")
        ).pack(pady=(10, 5))

        self.result_text = ctk.CTkTextbox(results_frame, width=1100, height=200)
        self.result_text.pack(pady=10, padx=10)

        # TestNo Viewer Section
        viewer_frame = ctk.CTkFrame(root)
        viewer_frame.grid(row=4, column=0, pady=10, padx=20, sticky="ew")
        
        ctk.CTkLabel(
            viewer_frame,
            text="View Individual TestNo:",
            font=ctk.CTkFont(size=14, weight="bold")
        ).pack(pady=(10, 5))

        testno_control_frame = ctk.CTkFrame(viewer_frame, fg_color="transparent")
        testno_control_frame.pack(pady=5)
        
        self.testno_var = ctk.StringVar()
        self.testno_selector = ctk.CTkComboBox(
            testno_control_frame,
            variable=self.testno_var,
            values=[""],
            width=200,
            height=35,
            state="readonly"
        )
        self.testno_selector.pack(side="left", padx=5)
        
        self.btn_view_test = ctk.CTkButton(
            testno_control_frame,
            text="View Selected TestNo",
            command=self.view_testno,
            width=200,
            height=35
        )
        self.btn_view_test.pack(side="left", padx=5)

        # Export buttons
        export_frame = ctk.CTkFrame(root)
        export_frame.grid(row=5, column=0, pady=10, padx=20, sticky="ew")
        
        ctk.CTkLabel(
            export_frame,
            text="Export Options:",
            font=ctk.CTkFont(size=14, weight="bold")
        ).pack(pady=(10, 5))

        button_container = ctk.CTkFrame(export_frame, fg_color="transparent")
        button_container.pack(pady=10)
        
        self.btn_save_csv = ctk.CTkButton(
            button_container,
            text="ðŸ’¾ Save All Data to CSV",
            command=self.save_csv,
            width=250,
            height=40,
            font=ctk.CTkFont(size=13)
        )
        self.btn_save_csv.pack(side="left", padx=10)
        
        self.btn_save_ipynb = ctk.CTkButton(
            button_container,
            text="ðŸ““ Export Jupyter Notebook",
            command=self.save_ipynb,
            width=250,
            height=40,
            font=ctk.CTkFont(size=13)
        )
        self.btn_save_ipynb.pack(side="left", padx=10)

    def get_column_count_text(self):
        text = ""
        for col in self.collector.columns:
            text += f"{col}: {len(self.collector.data[col])} records  |  "
        return text.strip(" | ")

    def update_chunk_count(self, event=None):
        self.chunk_count_label.configure(text=self.get_column_count_text())

    def add_chunk(self):
        col = self.col_var.get()
        chunk = self.textbox.get("1.0", "end")
        count = self.collector.add_chunk(col, chunk)
        self.textbox.delete("1.0", "end")
        self.update_chunk_count()
        messagebox.showinfo("Chunk Added", f"Added {count} values to {col}.")

    def finish(self):
        if not self.collector.ready():
            messagebox.showerror("Error", "Not all columns have the same number of records. Please check your data.")
            return
        unique_testnos = self.collector.get_unique_testnos()
        AreaPrompt(self.root, unique_testnos, self.areas_callback)

    def areas_callback(self, areas):
        self.collector.areas = areas
        # Save processed data for export
        self.processed_rows = []
        n = len(self.collector.data["TestNo"])
        tensile_strengths = []
        playtimes = []
        for i in range(n):
            testno = self.collector.data["TestNo"][i]
            playtime = float(self.collector.data["PlayTime"][i])
            load = float(self.collector.data["LoadValue"][i])
            position = self.collector.data["PositionValue"][i]
            area = areas.get(testno)
            if area is not None:
                tensile_strength = load / area
                self.processed_rows.append([testno, playtime, load, position, area, tensile_strength])
                tensile_strengths.append(tensile_strength)
                playtimes.append(playtime)
        
        # Update TestNo dropdown
        unique_testnos = sorted(set(row[0] for row in self.processed_rows))
        self.testno_selector.configure(values=unique_testnos)
        if unique_testnos:
            self.testno_var.set(unique_testnos[0])
        
        # Display all results
        self.result_text.delete("1.0", "end")
        result = "TestNo\tPlayTime\tLoadValue\tPositionValue\tArea_mm2\tTensileStrength_MPa\n"
        result += "="*100 + "\n"
        for row in self.processed_rows:
            result += f"{row[0]}\t{row[1]}\t{row[2]}\t{row[3]}\t{row[4]}\t{row[5]:.2f}\n"
        max_strength = max((row[5] for row in self.processed_rows), default=None)
        if max_strength is not None:
            result += "\n" + "="*100 + "\n"
            result += f"MAX Tensile Strength: {max_strength:.2f} MPa\n"
        self.result_text.insert("1.0", result)
        
        # Plot all data with max annotation
        if tensile_strengths:
            sample_size = min(2000, len(tensile_strengths))
            sample_tensile = tensile_strengths[:sample_size]
            sample_playtime = playtimes[:sample_size]
            max_strength_val = max(sample_tensile)
            max_idx = sample_tensile.index(max_strength_val)
            max_playtime_val = sample_playtime[max_idx]
            
            plt.figure(figsize=(10,6))
            plt.plot(sample_playtime, sample_tensile, marker='.', linestyle='-', color='b')
            plt.scatter([max_playtime_val], [max_strength_val], color='r', zorder=5, s=100)
            plt.annotate(
                f'Max: {max_strength_val:.2f} MPa',
                xy=(max_playtime_val, max_strength_val),
                xytext=(max_playtime_val, max_strength_val + 0.05 * max_strength_val),
                arrowprops=dict(facecolor='red', shrink=0.05),
                fontsize=12,
                color='red',
                weight='bold'
            )
            plt.title('Tensile Strength vs PlayTime (All Data)', fontsize=16, weight='bold')
            plt.xlabel('PlayTime (s)', fontsize=12)
            plt.ylabel('Tensile Strength (MPa)', fontsize=12)
            plt.grid(True, alpha=0.3)
            plt.tight_layout()
            plt.show()

    def view_testno(self):
        testno = self.testno_var.get()
        if not testno:
            messagebox.showwarning("No TestNo Selected", "Please select a TestNo to view.")
            return
        rows = [row for row in self.processed_rows if row[0] == testno]
        if not rows:
            messagebox.showinfo("TestNo Not Found", f"No data found for TestNo {testno}.")
            return
        
        info = "TestNo\tPlayTime\tLoadValue\tPositionValue\tArea_mm2\tTensileStrength_MPa\n"
        playtimes = []
        tensile_strengths = []
        for row in rows:
            info += f"{row[0]}\t{row[1]}\t{row[2]}\t{row[3]}\t{row[4]}\t{row[5]:.2f}\n"
            playtimes.append(row[1])
            tensile_strengths.append(row[5])
        max_strength = max((row[5] for row in rows), default=None)
        if max_strength is not None:
            info += f"\nMAX Tensile Strength for TestNo {testno}: {max_strength:.2f} MPa\n"
        
        # Show popup and plot with annotation
        messagebox.showinfo(f"Data for TestNo {testno}", info)
        
        if tensile_strengths:
            max_strength_val = max(tensile_strengths)
            max_idx = tensile_strengths.index(max_strength_val)
            max_playtime_val = playtimes[max_idx]
            
            plt.figure(figsize=(10,6))
            plt.plot(playtimes, tensile_strengths, marker='o', linestyle='-', color='g', linewidth=2)
            plt.scatter([max_playtime_val], [max_strength_val], color='r', zorder=5, s=150)
            plt.annotate(
                f'Max: {max_strength_val:.2f} MPa',
                xy=(max_playtime_val, max_strength_val),
                xytext=(max_playtime_val, max_strength_val + 0.05 * max_strength_val),
                arrowprops=dict(facecolor='red', shrink=0.05),
                fontsize=12,
                color='red',
                weight='bold'
            )
            plt.title(f'Tensile Strength vs PlayTime for TestNo {testno}', fontsize=16, weight='bold')
            plt.xlabel('PlayTime (s)', fontsize=12)
            plt.ylabel('Tensile Strength (MPa)', fontsize=12)
            plt.grid(True, alpha=0.3)
            plt.tight_layout()
            plt.show()

    def save_csv(self):
        if not self.processed_rows:
            messagebox.showerror("No Data", "No data to save. Please process your data first.")
            return
        file_path = filedialog.asksaveasfilename(defaultextension='.csv', filetypes=[("CSV files", "*.csv")])
        if not file_path:
            return
        with open(file_path, 'w', newline='') as f:
            writer = csv.writer(f)
            writer.writerow(["TestNo", "PlayTime", "LoadValue", "PositionValue", "Area_mm2", "TensileStrength_MPa"])
            for row in self.processed_rows:
                writer.writerow([row[0], row[1], row[2], row[3], row[4], f"{row[5]:.2f}"])
        messagebox.showinfo("Saved", f"All data saved to {file_path}")

    def save_ipynb(self):
        if not self.processed_rows:
            messagebox.showerror("No Data", "No data to save. Please process your data first.")
            return
        file_path = filedialog.asksaveasfilename(defaultextension='.ipynb', filetypes=[("Jupyter Notebook", "*.ipynb")])
        if not file_path:
            return
        nb = new_notebook()
        
        # Markdown overview
        nb.cells.append(new_markdown_cell("# Tensile Strength Data Analysis\nThis notebook contains your processed tensile strength data and visualization plots."))
        
        # Code for data
        code = "import pandas as pd\nimport matplotlib.pyplot as plt\n\n"
        code += "# Load data\n"
        code += "data = pd.DataFrame([\n"
        for row in self.processed_rows:
            code += f"    {row},\n"
        code += "], columns=['TestNo', 'PlayTime', 'LoadValue', 'PositionValue', 'Area_mm2', 'TensileStrength_MPa'])\n\n"
        code += "# Display summary\n"
        code += "print(f'Total records: {len(data)}')\n"
        code += "print(f'Max Tensile Strength: {data[\"TensileStrength_MPa\"].max():.2f} MPa')\n"
        code += "data.head()\n"
        nb.cells.append(new_code_cell(code))
        
        # Code for plot with max annotation
        plot_code = (
            "# Plot Tensile Strength vs PlayTime\n"
            "plt.figure(figsize=(12,7))\n"
            "plt.plot(data['PlayTime'], data['TensileStrength_MPa'], marker='.', linestyle='-', color='b', alpha=0.7)\n\n"
            "# Highlight maximum\n"
            "max_strength = data['TensileStrength_MPa'].max()\n"
            "max_idx = data['TensileStrength_MPa'].idxmax()\n"
            "max_playtime = data.loc[max_idx, 'PlayTime']\n"
            "plt.scatter([max_playtime], [max_strength], color='r', zorder=5, s=150)\n"
            "plt.annotate(\n"
            "    f'Max: {max_strength:.2f} MPa',\n"
            "    xy=(max_playtime, max_strength),\n"
            "    xytext=(max_playtime, max_strength + 0.05 * max_strength),\n"
            "    arrowprops=dict(facecolor='red', shrink=0.05),\n"
            "    fontsize=14,\n"
            "    color='red',\n"
            "    weight='bold'\n"
            ")\n\n"
            "plt.title('Tensile Strength vs PlayTime', fontsize=16, weight='bold')\n"
            "plt.xlabel('PlayTime (s)', fontsize=12)\n"
            "plt.ylabel('Tensile Strength (MPa)', fontsize=12)\n"
            "plt.grid(True, alpha=0.3)\n"
            "plt.tight_layout()\n"
            "plt.show()\n"
        )
        nb.cells.append(new_code_cell(plot_code))
        
        # Add statistics cell
        stats_code = (
            "# Statistical Summary\n"
            "print('='*50)\n"
            "print('TENSILE STRENGTH STATISTICS')\n"
            "print('='*50)\n"
            "print(f\"Mean: {data['TensileStrength_MPa'].mean():.2f} MPa\")\n"
            "print(f\"Median: {data['TensileStrength_MPa'].median():.2f} MPa\")\n"
            "print(f\"Std Dev: {data['TensileStrength_MPa'].std():.2f} MPa\")\n"
            "print(f\"Min: {data['TensileStrength_MPa'].min():.2f} MPa\")\n"
            "print(f\"Max: {data['TensileStrength_MPa'].max():.2f} MPa\")\n"
            "print('='*50)\n"
        )
        nb.cells.append(new_code_cell(stats_code))
        
        with open(file_path, 'w', encoding='utf-8') as f:
            nbformat.write(nb, f)
        messagebox.showinfo("Saved", f"Notebook exported to {file_path}")

if __name__ == "__main__":
    root = ctk.CTk()
    app = TensileStrengthGUI(root)
    root.mainloop()
